---
phase: 01-document-normalization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/models/document.py, src/models/page.py, src/pipeline/reader.py, src/pipeline/pdf_detection.py, tests/test_document.py, tests/test_page.py, tests/test_pdf_detection.py]
autonomous: true

must_haves:
  truths:
    - "System can read a PDF file and create Document object with metadata"
    - "System can detect whether PDF is searchable (has text layer) or scanned (image-only)"
    - "System can extract all pages from PDF as Page objects with correct dimensions"
    - "System routes to pdfplumber path for searchable PDFs"
    - "System routes to OCR path for scanned PDFs"
    - "System handles multi-page documents correctly"
  artifacts:
    - path: "src/models/document.py"
      provides: "Document data model with filename, filepath, page_count, pages"
      contains: "class Document"
    - path: "src/models/page.py"
      provides: "Page data model with page_number, width, height, reference to Document"
      contains: "class Page"
    - path: "src/pipeline/reader.py"
      provides: "PDF reading functionality using pdfplumber"
      exports: ["read_pdf", "extract_pages"]
    - path: "src/pipeline/pdf_detection.py"
      provides: "PDF type detection (searchable vs scanned) and routing logic"
      exports: ["detect_pdf_type", "route_extraction_path"]
  key_links:
    - from: "src/pipeline/reader.py"
      to: "src/models/document.py"
      via: "Creates Document instances"
      pattern: "Document\("
    - from: "src/pipeline/reader.py"
      to: "src/models/page.py"
      via: "Creates Page instances from Document"
      pattern: "Page\("
    - from: "src/pipeline/pdf_detection.py"
      to: "src/pipeline/reader.py"
      via: "Calls read_pdf and checks for text layer"
      pattern: "read_pdf|text_layer|has_text"
---

<objective>
Establish PDF reading foundation with type detection and routing.

Purpose: Enable system to read PDF invoices and determine extraction path (searchable PDF via pdfplumber or scanned PDF via OCR). This is the foundation for all downstream processing.
Output: Document and Page models, PDF reader, PDF type detection and routing logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-document-normalization/01-CONTEXT.md
@.planning/research/STACK.md
@docs/02_data-model.md
@specs/invoice_pipeline_v1.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Document and Page data models</name>
  <files>src/models/document.py, src/models/page.py</files>
  <action>
Create Document and Page classes according to docs/02_data-model.md specifications.

Document class:
- filename: str (PDF filename)
- filepath: str (full path to PDF file)
- page_count: int (number of pages)
- pages: List[Page] (list of Page objects)
- metadata: Dict[str, Any] (optional additional metadata)

Page class:
- page_number: int (starts at 1)
- document: Document (reference to parent Document)
- width: float (page width in points)
- height: float (page height in points)
- tokens: List[Token] (initially empty, populated later)
- rendered_image_path: Optional[str] (for OCR path, initially None)

Use dataclasses or Pydantic for data validation. Add type hints for Python 3.11+. Follow PEP 8 style. Ensure Page maintains reference to Document for traceability.
  </action>
  <verify>python -m mypy src/models/document.py src/models/page.py --python-version 3.11</verify>
  <done>Document and Page classes defined with all required fields, type hints pass mypy validation</done>
</task>

<task type="auto">
  <name>Task 2: Implement PDF reader with pdfplumber</name>
  <files>src/pipeline/reader.py</files>
  <action>
Implement PDF reading functionality using pdfplumber library.

Functions to implement:
- `read_pdf(filepath: str) -> Document`: Opens PDF with pdfplumber, creates Document object, extracts all pages as Page objects with width/height from pdfplumber page dimensions.

For each page, create Page object with:
- page_number (1-indexed)
- width, height from pdfplumber page dimensions
- document reference
- tokens list initially empty
- rendered_image_path initially None

Handle multi-page PDFs correctly. All pages must be extracted even for single-page invoices. Extract page dimensions accurately for coordinate system consistency (required for spatial analysis).

Error handling: Raise custom exceptions for corrupt PDFs or read failures. Log errors for debugging.
  </action>
  <verify>python -c "from src.pipeline.reader import read_pdf; doc = read_pdf('tests/fixtures/pdfs/sample_invoice_1.pdf'); assert doc.page_count > 0; assert len(doc.pages) == doc.page_count"</verify>
  <done>read_pdf function creates Document with correct page_count and Page objects with accurate width/height</done>
</task>

<task type="auto">
  <name>Task 3: Implement PDF type detection and routing</name>
  <files>src/pipeline/pdf_detection.py</files>
  <action>
Implement PDF type detection to route to appropriate extraction path (searchable vs scanned).

Function to implement:
- `detect_pdf_type(document: Document) -> str`: Returns "searchable" or "scanned"
- `route_extraction_path(document: Document) -> str`: Returns extraction path identifier

Detection logic:
- Use pdfplumber to check if PDF has extractable text layer
- If pdfplumber can extract text tokens with position info → "searchable"
- If pdfplumber returns minimal/no text → "scanned" (requires OCR path)

Return structured result indicating:
- PDF type: "searchable" or "scanned"
- Confidence: HIGH if clear, MEDIUM if ambiguous
- Text layer info: percentage of pages with extractable text

This enables downstream steps to choose pdfplumber path (fast) vs OCR path (slower but necessary for scanned PDFs). Design with OCR abstraction in mind (Phase 2 will add OCR engine abstraction layer).

Error handling: If detection fails, default to "scanned" (safer fallback - OCR can handle both, but pdfplumber cannot handle image-only).
  </action>
  <verify>python -c "from src.pipeline.reader import read_pdf; from src.pipeline.pdf_detection import detect_pdf_type; doc = read_pdf('tests/fixtures/pdfs/sample_invoice_1.pdf'); pdf_type = detect_pdf_type(doc); assert pdf_type in ['searchable', 'scanned']"</verify>
  <done>detect_pdf_type correctly identifies searchable vs scanned PDFs, routing logic returns appropriate path identifier</done>
</task>

<task type="auto">
  <name>Task 4: Write unit tests for PDF reading and detection</name>
  <files>tests/test_document.py, tests/test_page.py, tests/test_pdf_detection.py</files>
  <action>
Create comprehensive unit tests for Document, Page, PDF reader, and PDF detection.

Tests to write:
- test_document.py: Document creation, metadata extraction, page_count accuracy
- test_page.py: Page creation, width/height extraction, document reference
- test_pdf_detection.py: PDF type detection for both searchable and scanned PDFs (if test corpus has both types)

Use pytest fixtures for test PDFs. Test with sample_invoice_1.pdf from tests/fixtures/pdfs/. Verify:
- Document created with correct metadata
- All pages extracted (even for single-page PDF)
- Page dimensions are accurate (non-zero, reasonable values)
- PDF type detection works correctly

Follow pytest best practices. Use pytest fixtures for reusable test data. Ensure tests run with `pytest tests/test_document.py tests/test_page.py tests/test_pdf_detection.py -v`.
  </action>
  <verify>pytest tests/test_document.py tests/test_page.py tests/test_pdf_detection.py -v</verify>
  <done>All unit tests pass, coverage >80% for Document, Page, reader, and pdf_detection modules</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_document.py tests/test_page.py tests/test_pdf_detection.py -v passes
- [ ] mypy type checking passes for all new files
- [ ] Can read sample_invoice_1.pdf and create Document with correct page_count
- [ ] PDF type detection works (returns "searchable" or "scanned")
- [ ] Multi-page PDF handling verified
</verification>

<success_criteria>

- All tasks completed
- Document and Page models match docs/02_data-model.md specification
- PDF reader successfully extracts pages from PDFs
- PDF type detection correctly identifies searchable vs scanned
- Unit tests pass with >80% coverage
- No type errors or linting issues

</success_criteria>

<output>
After completion, create `.planning/phases/01-document-normalization/01-01-SUMMARY.md`
</output>
