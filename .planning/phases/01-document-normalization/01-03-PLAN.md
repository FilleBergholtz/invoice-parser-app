---
phase: 01-document-normalization
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified: [src/models/row.py, src/models/segment.py, src/pipeline/row_grouping.py, src/pipeline/segment_identification.py, tests/test_row_grouping.py, tests/test_segment_identification.py]
autonomous: true

must_haves:
  truths:
    - "System groups tokens into rows based on Y-position alignment"
    - "Row grouping preserves reading order (top-to-bottom)"
    - "System identifies document segments (header, items/body, footer) based on position and content"
    - "Each row maintains reference to its tokens for traceability"
    - "Each segment maintains reference to its rows for traceability"
  artifacts:
    - path: "src/models/row.py"
      provides: "Row data model with tokens, y, x_min, x_max, text, page reference"
      contains: "class Row"
    - path: "src/models/segment.py"
      provides: "Segment data model with segment_type, rows, y_min, y_max, page reference"
      contains: "class Segment"
    - path: "src/pipeline/row_grouping.py"
      provides: "Token-to-row grouping based on Y-position alignment"
      exports: ["group_tokens_to_rows"]
    - path: "src/pipeline/segment_identification.py"
      provides: "Row-to-segment identification (header, items, footer)"
      exports: ["identify_segments"]
  key_links:
    - from: "src/pipeline/row_grouping.py"
      to: "src/models/row.py"
      via: "Creates Row instances from Token groups"
      pattern: "Row\("
    - from: "src/models/row.py"
      to: "src/models/token.py"
      via: "Row.tokens contains Token references"
      pattern: "tokens:.*List\[Token\]"
    - from: "src/pipeline/segment_identification.py"
      to: "src/models/segment.py"
      via: "Creates Segment instances from Row groups"
      pattern: "Segment\("
    - from: "src/models/segment.py"
      to: "src/models/row.py"
      via: "Segment.rows contains Row references"
      pattern: "rows:.*List\[Row\]"
---

<objective>
Implement layout analysis: group tokens into rows, then rows into segments.

Purpose: Create stable document structure (rows and segments) that preserves spatial information and enables downstream line item extraction. Layout-driven approach (tokens→rows→segments) not table-extractor-driven.
Output: Row and Segment models, row grouping logic, segment identification logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-document-normalization/01-CONTEXT.md
@docs/02_data-model.md
@specs/invoice_pipeline_v1.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Row and Segment data models</name>
  <files>src/models/row.py, src/models/segment.py</files>
  <action>
Create Row and Segment classes according to docs/02_data-model.md specifications.

Row class:
- tokens: List[Token] (KÄLLSANING - use this for traceability, all tokens in the row)
- y: float (Y-coordinate for the row - median or first token's Y)
- x_min: float (minimum X in row)
- x_max: float (maximum X in row)
- text: str (CONVENIENCE - concatenated text from all tokens, for easy access)
- page: Page (reference to parent Page)

Important: tokens is the source of truth. text is convenience only. Downstream code should use tokens/bbox for traceability and exact positioning.

Segment class:
- segment_type: str ("header", "items", or "footer")
- rows: List[Row] (rows in this segment)
- y_min: float (minimum Y-coordinate)
- y_max: float (maximum Y-coordinate)
- page: Page (reference to parent Page)

Use dataclasses or Pydantic. Add type hints. Ensure both maintain references for full traceability.
  </action>
  <verify>python -m mypy src/models/row.py src/models/segment.py --python-version 3.11</verify>
  <done>Row and Segment classes defined with all required fields, tokens/rows are source of truth, type hints pass mypy validation</done>
</task>

<task type="auto">
  <name>Task 2: Implement row grouping from tokens</name>
  <files>src/pipeline/row_grouping.py</files>
  <action>
Implement token-to-row grouping based on Y-position alignment.

Function to implement:
- `group_tokens_to_rows(tokens: List[Token]) -> List[Row]`: Groups tokens into rows based on Y-position.

Algorithm:
- Sort tokens by Y-position (top-to-bottom)
- Group tokens with similar Y-coordinates (within tolerance, e.g., 5 points or 2% of page height)
- For each group, create Row with:
  - tokens: all tokens in the group (preserve order within row - left-to-right)
  - y: median Y of tokens in group
  - x_min: minimum x of all tokens
  - x_max: maximum x of all tokens
  - text: concatenated text from tokens (with spaces between)
  - page: reference from first token's page

Preserve reading order: rows ordered top-to-bottom. Within row, tokens ordered left-to-right (sort by x within same Y-group).

Tolerance for Y-position: Use small tolerance (2-5 points) to handle slight variations in token positioning. Test with sample_invoice_1.pdf to ensure robust grouping.

Error handling: Handle empty token lists, invalid coordinates. Log warnings for unusual row structures.
  </action>
  <verify>python -c "from src.pipeline.reader import read_pdf; from src.pipeline.tokenizer import extract_tokens_from_page; from src.pipeline.row_grouping import group_tokens_to_rows; import pdfplumber; doc = read_pdf('tests/fixtures/pdfs/sample_invoice_1.pdf'); pdf = pdfplumber.open(doc.filepath); page = doc.pages[0]; tokens = extract_tokens_from_page(page, pdf.pages[0]); rows = group_tokens_to_rows(tokens); assert len(rows) > 0; assert all(len(r.tokens) > 0 for r in rows); assert rows[0].y < rows[-1].y  # Top-to-bottom order"</verify>
  <done>group_tokens_to_rows correctly groups tokens into rows by Y-position, preserves reading order top-to-bottom, Row.tokens maintains traceability</done>
</task>

<task type="auto">
  <name>Task 3: Implement segment identification from rows</name>
  <files>src/pipeline/segment_identification.py</files>
  <action>
Implement row-to-segment identification (header, items, footer) based on position and content.

Function to implement:
- `identify_segments(rows: List[Row], page: Page) -> List[Segment]`: Identifies segments from rows.

Algorithm:
- Calculate page regions:
  - Header: top 20-30% of page (rows with y < 0.3 * page.height)
  - Footer: bottom 20-30% of page (rows with y > 0.7 * page.height)
  - Items: middle section (rows between header and footer)
- Create Segment objects:
  - Header segment: segment_type="header", all header rows
  - Items segment: segment_type="items", all items rows
  - Footer segment: segment_type="footer", all footer rows (if exists)
- Set y_min, y_max from row positions
- Maintain page reference

Content-based heuristics (for refinement):
- Header: Look for keywords like "Faktura", "Invoice", company names in top region
- Footer: Look for "Total", "Summa", numeric amounts in bottom region
- Items: Middle section, often contains table-like structure

Start with position-based segmentation (simpler, more robust). Content-based heuristics can be refined later. The goal is stable segmentation even if it's rough - downstream parsing will use segments to guide extraction.

Handle edge cases: Single-page invoices, invoices without clear footer, very short invoices.
  </action>
  <verify>python -c "from src.pipeline.reader import read_pdf; from src.pipeline.tokenizer import extract_tokens_from_page; from src.pipeline.row_grouping import group_tokens_to_rows; from src.pipeline.segment_identification import identify_segments; import pdfplumber; doc = read_pdf('tests/fixtures/pdfs/sample_invoice_1.pdf'); pdf = pdfplumber.open(doc.filepath); page = doc.pages[0]; tokens = extract_tokens_from_page(page, pdf.pages[0]); rows = group_tokens_to_rows(tokens); segments = identify_segments(rows, page); assert len(segments) >= 2  # At least header and items; assert any(s.segment_type == 'header' for s in segments); assert any(s.segment_type == 'items' for s in segments)"</verify>
  <done>identify_segments correctly identifies header, items, and footer segments based on position, Segment.rows maintains traceability, segmentation works for test invoice</done>
</task>

<task type="auto">
  <name>Task 4: Write unit tests for row grouping and segment identification</name>
  <files>tests/test_row_grouping.py, tests/test_segment_identification.py</files>
  <action>
Create unit tests for row grouping and segment identification.

Tests to write:
- test_row_grouping.py:
  - Test token grouping into rows by Y-position
  - Test reading order preservation (top-to-bottom)
  - Test row bbox calculation (x_min, x_max, y)
  - Test Row.tokens traceability (all tokens have correct page reference)
  - Test edge cases: empty tokens, single token per row, overlapping Y positions

- test_segment_identification.py:
  - Test segment identification (header, items, footer)
  - Test position-based segmentation (top 30% = header, etc.)
  - Test Segment.rows traceability
  - Test edge cases: single-page invoices, missing footer, very short invoices

Test with sample_invoice_1.pdf. Verify:
- Rows correctly group tokens by Y-position
- Reading order preserved (top-to-bottom)
- Segments identified correctly
- All traceability links maintained (Row.tokens, Segment.rows, Token.page, Row.page, Segment.page)

Use pytest fixtures. Ensure tests run with `pytest tests/test_row_grouping.py tests/test_segment_identification.py -v`.
  </action>
  <verify>pytest tests/test_row_grouping.py tests/test_segment_identification.py -v</verify>
  <done>All layout analysis unit tests pass, coverage >80% for row_grouping and segment_identification modules, traceability verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_row_grouping.py tests/test_segment_identification.py -v passes
- [ ] mypy type checking passes for all new files
- [ ] Tokens grouped into rows with correct Y-position alignment
- [ ] Reading order preserved (top-to-bottom)
- [ ] Segments identified (header, items, footer)
- [ ] All traceability maintained (Row.tokens, Segment.rows)
</verification>

<success_criteria>

- All tasks completed
- Row and Segment models match docs/02_data-model.md specification
- Row grouping correctly groups tokens by Y-position with tolerance
- Segment identification correctly identifies header/items/footer based on position
- Reading order preserved throughout (top-to-bottom)
- Full traceability: Row→Token→Page, Segment→Row→Token→Page
- Unit tests pass with >80% coverage
- No type errors or linting issues

</success_criteria>

<output>
After completion, create `.planning/phases/01-document-normalization/01-03-SUMMARY.md`
</output>
