---
phase: 01-document-normalization
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified: [src/models/invoice_line.py, src/pipeline/invoice_line_parser.py, tests/test_invoice_line_parser.py]
autonomous: true

must_haves:
  truths:
    - "System extracts line items from items segment using layout-driven approach"
    - "Line items identified by rule: 'rad med belopp = produktrad' (row with amount = product row)"
    - "Line items maintain traceability back to Row/Token/Page"
    - "System handles line items spanning multiple pages"
  artifacts:
    - path: "src/models/invoice_line.py"
      provides: "InvoiceLine data model with description, quantity, unit_price, total_amount, rows reference"
      contains: "class InvoiceLine"
    - path: "src/pipeline/invoice_line_parser.py"
      provides: "Line item extraction from items segment using layout-driven approach"
      exports: ["extract_invoice_lines"]
  key_links:
    - from: "src/pipeline/invoice_line_parser.py"
      to: "src/models/invoice_line.py"
      via: "Creates InvoiceLine instances from Segment rows"
      pattern: "InvoiceLine\("
    - from: "src/models/invoice_line.py"
      to: "src/models/row.py"
      via: "InvoiceLine.rows contains Row references (KÄLLSANING for traceability)"
      pattern: "rows:.*List\[Row\]"
    - from: "src/pipeline/invoice_line_parser.py"
      to: "src/models/segment.py"
      via: "Processes Segment with segment_type='items'"
      pattern: "segment_type.*items|segment\\.segment_type"
---

<objective>
Extract line items from items segment using layout-driven approach.

Purpose: Identify product rows from items segment. Rule: "rad med belopp = produktrad" (row with amount = product row). Layout-driven means tokens→rows→segments, not table-extractor-driven. Multi-page support for tables spanning pages.
Output: InvoiceLine model, line item parser extracting description, quantity, unit price, total amount.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-document-normalization/01-CONTEXT.md
@docs/02_data-model.md
@specs/invoice_pipeline_v1.md
@docs/04_heuristics.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InvoiceLine data model</name>
  <files>src/models/invoice_line.py</files>
  <action>
Create InvoiceLine class according to docs/02_data-model.md specifications.

InvoiceLine class:
- rows: List[Row] (KÄLLSANING - rows that belong to this line item, including wraps, use for traceability)
- description: str (product/service description)
- quantity: Optional[float] (quantity)
- unit: Optional[str] (unit like "st", "kg", "h", "m²")
- unit_price: Optional[float] (unit price)
- discount: Optional[float] (discount as decimal or amount)
- total_amount: float (total amount for the line - REQUIRED, this is what identifies product rows)
- vat_rate: Optional[float] (VAT rate for this line)
- line_number: int (line number for ordering)
- segment: Segment (reference to items segment)

Important: rows is KÄLLSANING for traceability. In Phase 1, rows will typically contain one Row (wrapped text handling comes in Phase 2). total_amount is the key identifier - rule: "rad med belopp = produktrad".

Use dataclass or Pydantic. Add type hints. Ensure InvoiceLine maintains segment and rows references for full traceability back to Page/Token.
  </action>
  <verify>python -m mypy src/models/invoice_line.py --python-version 3.11</verify>
  <done>InvoiceLine class defined with all required fields including rows (traceability), total_amount (required), type hints pass mypy validation</done>
</task>

<task type="auto">
  <name>Task 2: Implement line item parser (layout-driven approach)</name>
  <files>src/pipeline/invoice_line_parser.py</files>
  <action>
Implement line item extraction from items segment using layout-driven approach (tokens→rows→segments), NOT table-extractor-driven.

Function to implement:
- `extract_invoice_lines(items_segment: Segment) -> List[InvoiceLine]`: Extracts line items from items segment.

Algorithm (layout-driven):
- Iterate through Segment.rows (these are already grouped by Y-position)
- For each row, check if it contains a numeric amount (total_amount)
- Rule: "rad med belopp = produktrad" - if row contains amount, it's a product row
- Extract fields from row tokens:
  - total_amount: Numeric value (usually in rightmost column or after currency symbol)
  - description: Text before numeric columns (leftmost text, may span multiple tokens)
  - quantity: Optional numeric (often second or third column)
  - unit: Optional string (often after quantity, like "st", "kg")
  - unit_price: Optional numeric (often before total_amount)
  - discount: Optional numeric (rare in Phase 1, can be None)

Heuristics:
- Identify numeric columns by pattern: right-aligned numbers, currency symbols (SEK, kr), decimal points
- Description: Leftmost text, concatenate tokens until first numeric column
- Amount: Rightmost numeric value or numeric after "totalt"/"summa" keywords

Layout-driven means: Use spatial information (token positions, column alignment) to identify fields, not rely on table detection. pdfplumber table detection can be helper for alignment hints, but NOT single point of failure.

Multi-page support:
- When processing Document, combine items segments from all pages
- Maintain line_number across pages (increment globally)
- Track which page each InvoiceLine comes from via Row.page reference

Error handling: If row has no amount, skip it (not a product row). Log warnings for rows that look like product rows but missing amount.
  </action>
  <verify>python -c "from src.pipeline.reader import read_pdf; from src.pipeline.tokenizer import extract_tokens_from_page; from src.pipeline.row_grouping import group_tokens_to_rows; from src.pipeline.segment_identification import identify_segments; from src.pipeline.invoice_line_parser import extract_invoice_lines; import pdfplumber; doc = read_pdf('tests/fixtures/pdfs/sample_invoice_1.pdf'); pdf = pdfplumber.open(doc.filepath); page = doc.pages[0]; tokens = extract_tokens_from_page(page, pdf.pages[0]); rows = group_tokens_to_rows(tokens); segments = identify_segments(rows, page); items_segment = next(s for s in segments if s.segment_type == 'items'); lines = extract_invoice_lines(items_segment); assert len(lines) > 0; assert all(line.total_amount > 0 for line in lines); assert all(len(line.rows) > 0 for line in lines)"</verify>
  <done>extract_invoice_lines extracts line items using layout-driven approach, identifies product rows by amount, maintains traceability via InvoiceLine.rows</done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for line item extraction</name>
  <files>tests/test_invoice_line_parser.py</files>
  <action>
Create unit tests for line item extraction.

Tests to write:
- Test extraction from items segment
- Test "rad med belopp = produktrad" rule (rows with amount become InvoiceLines)
- Test field extraction (description, quantity, unit_price, total_amount)
- Test traceability (InvoiceLine.rows maintains Row references)
- Test multi-page support (combine items segments from multiple pages)
- Test edge cases: rows without amounts (should be skipped), missing fields (quantity/unit_price optional)

Test with sample_invoice_1.pdf. Verify:
- Line items extracted correctly
- Each InvoiceLine has total_amount (required)
- Each InvoiceLine.rows maintains traceability
- Line numbers assigned correctly

Use pytest fixtures. Ensure tests run with `pytest tests/test_invoice_line_parser.py -v`.
  </action>
  <verify>pytest tests/test_invoice_line_parser.py -v</verify>
  <done>All line item extraction unit tests pass, coverage >80% for invoice_line_parser module, traceability verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_invoice_line_parser.py -v passes
- [ ] mypy type checking passes for all new files
- [ ] Line items extracted from items segment
- [ ] Rule "rad med belopp = produktrad" correctly identifies product rows
- [ ] InvoiceLine.rows maintains traceability
- [ ] Multi-page support works (combines items segments)
</verification>

<success_criteria>

- All tasks completed
- InvoiceLine model matches docs/02_data-model.md specification
- Line item parser uses layout-driven approach (not table-extractor-driven)
- Product rows identified by amount (rule: "rad med belopp = produktrad")
- Fields extracted: description, quantity, unit, unit_price, total_amount
- Full traceability: InvoiceLine→Row→Token→Page
- Unit tests pass with >80% coverage
- No type errors or linting issues

</success_criteria>

<output>
After completion, create `.planning/phases/01-document-normalization/01-04-SUMMARY.md`
</output>
