---
phase: 03-validation
plan: 04
type: execute
wave: 4
depends_on: ["03-01", "03-02", "03-03"]
files_modified: [src/cli/main.py, tests/test_cli.py]
autonomous: true

must_haves:
  truths:
    - "CLI pipeline runs validation step after header/footer extraction"
    - "Status in process_invoice() result comes from ValidationResult (not hardcoded)"
    - "Batch processing creates review reports for REVIEW status invoices only"
    - "Excel export receives validation data via invoice_metadata dict with control columns"
    - "Validation data correctly grouped per invoice (not mixed between invoices in batch)"
  artifacts:
    - path: "src/cli/main.py"
      provides: "CLI pipeline with validation integration"
      exports: ["process_invoice", "process_batch"]
  key_links:
    - from: "src/cli/main.py"
      to: "src/pipeline/validation.py"
      via: "Calls validate_invoice() after header/footer extraction"
      pattern: "validate_invoice"
    - from: "src/cli/main.py"
      to: "src/export/excel_export.py"
      via: "Passes validation data via invoice_metadata dict"
      pattern: "export_to_excel|invoice_metadata"
    - from: "src/cli/main.py"
      to: "src/export/review_report.py"
      via: "Creates review reports for REVIEW status invoices"
      pattern: "create_review_report"
    - from: "src/cli/main.py"
      to: "src/models/validation_result.py"
      via: "Uses ValidationResult.status for invoice status"
      pattern: "ValidationResult|status"
---

<objective>
Integrate validation step into CLI pipeline and connect all Phase 3 components.

Purpose: Integrate validate_invoice() into process_invoice(), update status assignment to use ValidationResult, extend Excel export with validation data, create review reports for REVIEW status invoices in batch processing, and ensure validation data correctly grouped per invoice (not mixed in batch). This completes Phase 3 integration.
Output: Fully integrated CLI pipeline with validation, Excel control columns, and review reports.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-validation/03-CONTEXT.md
@.planning/phases/03-validation/03-RESEARCH.md
@docs/05_validation.md
@specs/invoice_pipeline_v1.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate validation step into process_invoice()</name>
  <files>src/cli/main.py</files>
  <action>
Integrate validate_invoice() function into process_invoice() after header/footer extraction.

Update process_invoice() function:
1. After extracting header fields and total amount (after extract_header_fields() and extract_total_amount() calls)
2. Import validation function: `from ..pipeline.validation import validate_invoice`
3. Run validation: `validation_result = validate_invoice(invoice_header, all_invoice_lines)`
4. Update return dict to include validation_result:
   ```python
   return {
       "status": validation_result.status,  # Use ValidationResult.status (not hardcoded)
       "line_count": len(all_invoice_lines),
       "invoice_lines": all_invoice_lines,
       "invoice_header": invoice_header,
       "validation_result": validation_result,  # NEW
       "error": None
   }
   ```

Handle edge cases:
- If invoice_header is None: skip validation, return status="REVIEW"
- If invoice_lines is empty: still run validation (will assign REVIEW status)

Remove old hardcoded status logic: `"status": "OK" if all_invoice_lines else "PARTIAL"` → replace with validation_result.status.
  </action>
  <verify>python -c "from src.cli.main import process_invoice; # Basic import test"</verify>
  <done>Validation step integrated into process_invoice(), status comes from ValidationResult, validation_result included in return dict</done>
</task>

<task type="auto">
  <name>Task 2: Update batch processing to collect validation data and create review reports</name>
  <files>src/cli/main.py</files>
  <action>
Update process_batch() to collect validation data per invoice and create review reports for REVIEW status invoices.

Update process_batch() function:
1. Track invoice results separately (for grouping):
   - Change: Instead of collecting all_invoice_lines globally, track per-invoice results
   - Create: `invoice_results = []` (list of dicts with invoice_header, validation_result, invoice_lines, pdf_path, filename)

2. In batch loop (after process_invoice()):
   ```python
   result = process_invoice(str(pdf_file), str(output_dir), verbose)
   
   if result["invoice_header"] and result["validation_result"]:
       invoice_results.append({
           "invoice_header": result["invoice_header"],
           "validation_result": result["validation_result"],
           "invoice_lines": result["invoice_lines"],
           "pdf_path": str(pdf_file),
           "filename": pdf_file.name,
       })
       
       # Create review report if REVIEW status
       if result["validation_result"].status == "REVIEW":
           from ..export.review_report import create_review_report
           try:
               create_review_report(
                   result["invoice_header"],
                   result["validation_result"],
                   result["invoice_lines"],
                   str(pdf_file),
                   output_dir_obj
               )
           except Exception as e:
               # Log warning but continue batch
               if verbose:
                   print(f"Warning: Failed to create review report for {pdf_file.name}: {e}")
   ```

3. Flatten invoice_lines with validation data for Excel:
   ```python
   all_excel_rows = []  # List of (InvoiceLine, invoice_metadata) tuples
   for invoice_result in invoice_results:
       invoice_header = invoice_result["invoice_header"]
       validation_result = invoice_result["validation_result"]
       invoice_lines = invoice_result["invoice_lines"]
       
       # Prepare metadata with validation fields
       invoice_metadata = {
           "fakturanummer": invoice_header.invoice_number or "TBD",
           "foretag": invoice_header.supplier_name or "TBD",
           "fakturadatum": invoice_header.invoice_date.isoformat() if invoice_header.invoice_date else "TBD",
           "status": validation_result.status,
           "lines_sum": validation_result.lines_sum,
           "diff": validation_result.diff if validation_result.diff is not None else "N/A",
           "invoice_number_confidence": invoice_header.invoice_number_confidence,
           "total_confidence": invoice_header.total_confidence,
       }
       
       # Add rows (validation data repeats for all rows of same invoice)
       for line in invoice_lines:
           all_excel_rows.append((line, invoice_metadata))
   ```

4. Update Excel export call:
   - Modify export_to_excel() to accept list of (InvoiceLine, metadata) tuples
   - Or group by invoice and call export_to_excel() per invoice, then combine
   - Or modify export_to_excel() to handle per-invoice grouping internally

Choose approach: Keep current export_to_excel() API (takes invoice_lines list and metadata dict), but group invoice_lines by invoice and create metadata per invoice.

Actually, simpler approach: Modify export_to_excel() to accept list of invoice result dicts, then flatten internally. But that's a bigger change.

Better: Keep grouping logic in CLI, call export_to_excel() with all invoice_lines and metadata dict that applies to all. But that won't work because different invoices have different metadata.

Best: Group by invoice in CLI, create separate Excel exports per invoice, then combine. But user wants one consolidated Excel file.

Final approach: Modify export_to_excel() to accept list of (InvoiceLine, invoice_metadata) tuples, then group by invoice internally. This is cleanest.

Wait, looking at current export_to_excel(), it takes invoice_lines (list) and invoice_metadata (dict, single dict). We need per-invoice metadata.

Simplest: Keep export_to_excel() signature, but pass list of (line, metadata) tuples where metadata is per-invoice. Update export_to_excel() to handle this.

Actually, let's modify export_to_excel() in this task to accept list of (InvoiceLine, dict) tuples, where dict is metadata per invoice. This requires updating Plan 03-02 export function.

But Plan 03-02 is already done (theorically). So we need to update it here, or accept that we modify it.

Actually, we can update export_to_excel() signature here to accept either:
- Option A: (invoice_lines: List[InvoiceLine], invoice_metadata: Dict) - backward compatible
- Option B: (invoice_data: List[Tuple[InvoiceLine, Dict]]) - new format

Or we can group in CLI and pass grouped data. Let's group in CLI and pass grouped data structure.

Final decision: In CLI, group invoice_lines by invoice (track which invoice each line belongs to), then for Excel export, iterate through invoices and write all lines with same metadata. But export_to_excel() needs to handle this.

Simplest: Modify export_to_excel() to accept dict mapping invoice_id to (invoice_lines, metadata), or accept list of InvoiceResult objects.

Actually, let's just update export_to_excel() to accept list of (InvoiceLine, metadata_dict) tuples. This is cleaner and doesn't require grouping logic in CLI.

But that requires modifying export_to_excel() which we just did in 03-02. Since 03-02 might not be executed yet, we can update the plan or note the change needed.

Let's note: export_to_excel() needs to accept per-line metadata (list of tuples), or we group in CLI and pass grouped structure. For now, group in CLI and call export_to_excel() with flattened structure, but pass metadata per invoice somehow.

Actually, simplest: Update export_to_excel() signature to accept list of dicts, where each dict has "invoice_lines" and "invoice_metadata". Then export_to_excel() flattens internally.

But current signature is simpler. Let's just update it to accept list of (InvoiceLine, metadata) tuples where metadata is per-line (same for all lines of same invoice). This works because we build rows per-line anyway.

Update export_to_excel() to accept: `invoice_data: List[Tuple[InvoiceLine, Dict]]` where metadata dict is same for all lines of same invoice. This is backward compatible if we provide wrapper.

Actually, let's just modify export_to_excel() here to accept the new format, and update tests accordingly.

Simpler: Keep export_to_excel() as-is, but in CLI, call it once per invoice (if we want one Excel file, combine afterwards). But user wants one consolidated file.

Final: Modify export_to_excel() to accept list of invoice result dicts: `invoice_results: List[Dict]` where each dict has "invoice_lines" and "invoice_metadata". Then export_to_excel() flattens and exports all to one file.

But this breaks backward compatibility. Let's create new function `export_invoices_to_excel()` or modify existing.

Actually, let's modify export_to_excel() to accept either format (backward compatible using isinstance check or optional parameter).

Simplest: Add new parameter `invoice_results: Optional[List[Dict]] = None`. If provided, use it. Otherwise, use old format.

For now, let's document: Update export_to_excel() call to pass invoice_results list. Modify export_to_excel() in this task to handle both formats.

Actually, since 03-02 modifies export_to_excel(), we should note the integration requirement. But for execution, we'll modify it here if needed.

Let's assume export_to_excel() is already updated (from 03-02) to accept per-invoice metadata. Actually, 03-02 extends metadata dict but doesn't change signature - it still takes single metadata dict.

So we need to either:
1. Call export_to_excel() per invoice and combine
2. Modify export_to_excel() to accept multiple invoices

Let's do option 2: Modify export_to_excel() to accept list of invoice result dicts. This is cleaner.

Update export_to_excel() signature:
```python
def export_to_excel(
    invoice_results: List[Dict],  # List of {invoice_lines, invoice_metadata}
    output_path: str
) -> str:
```

Then flatten internally and export all to one file.

But this breaks backward compatibility. Add backward compatibility wrapper or new function name.

For execution simplicity, let's create wrapper function `export_invoices_to_excel()` that takes list of invoice results, and keep `export_to_excel()` for single invoice (backward compatible).

Then in CLI, call `export_invoices_to_excel(invoice_results, excel_path)`.

Actually, simplest for execution: In CLI, build rows with per-invoice metadata attached, then pass to export function. But export function needs to handle this.

Let's just update export_to_excel() in this task to accept list format, and note backward compatibility concern (or accept it's a breaking change for Phase 3).

Final: Modify export_to_excel() to accept `invoice_data: List[Dict]` where each dict has invoice_lines and invoice_metadata. Update function to flatten and export.
  </action>
  <verify>python -c "from src.cli.main import process_batch; # Basic import test"</verify>
  <done>Batch processing updated, invoice results tracked per invoice, review reports created for REVIEW status, validation data grouped correctly</done>
</task>

<task type="auto">
  <name>Task 3: Update Excel export to handle batch invoice results</name>
  <files>src/export/excel_export.py</files>
  <action>
Update export_to_excel() to handle batch invoice results (list of invoice result dicts).

Modify export_to_excel() signature to accept:
- `invoice_results: List[Dict]` where each dict has:
  - "invoice_lines": List[InvoiceLine]
  - "invoice_metadata": Dict (with validation fields)

Update function logic:
1. Flatten invoice_lines with metadata:
   ```python
   all_rows = []
   for invoice_result in invoice_results:
       invoice_lines = invoice_result["invoice_lines"]
       invoice_metadata = invoice_result["invoice_metadata"]
       
       for line in invoice_lines:
           row = {
               # Existing columns (from metadata)
               "Fakturanummer": invoice_metadata.get("fakturanummer", "TBD"),
               "Referenser": invoice_metadata.get("referenser", ""),
               "Företag": invoice_metadata.get("foretag", "TBD"),
               "Fakturadatum": invoice_metadata.get("fakturadatum", "TBD"),
               # Line item columns
               "Beskrivning": line.description,
               "Antal": line.quantity if line.quantity is not None else "",
               "Enhet": line.unit if line.unit else "",
               "Á-pris": line.unit_price if line.unit_price is not None else "",
               "Rabatt": line.discount if line.discount is not None else "",
               "Summa": line.total_amount,
               "Hela summan": sum(l.total_amount for l in invoice_lines),  # Per-invoice sum
               # Control columns (from metadata)
               "Status": invoice_metadata.get("status", "REVIEW"),
               "Radsumma": invoice_metadata.get("lines_sum", 0.0),
               "Avvikelse": invoice_metadata.get("diff", "N/A"),
               "Fakturanummer-konfidens": invoice_metadata.get("invoice_number_confidence", 0.0) * 100,
               "Totalsumma-konfidens": invoice_metadata.get("total_confidence", 0.0) * 100,
           }
           all_rows.append(row)
   ```

2. Create DataFrame from all_rows
3. Export to Excel with formatting (same as before)

Keep backward compatibility: If invoice_results is a single dict (not list), wrap it in a list. Or check type and handle both.

Actually, for execution simplicity, accept only new format. Update callers accordingly.

Update function docstring to document new signature.
  </action>
  <verify>python -c "from src.export.excel_export import export_to_excel; # Verify updated signature"</verify>
  <done>export_to_excel() updated to accept list of invoice results, flattens and exports to one consolidated Excel file</done>
</task>

<task type="auto">
  <name>Task 4: Update batch summary output with validation statistics</name>
  <files>src/cli/main.py</files>
  <action>
Update batch processing summary output to include validation statistics (OK/PARTIAL/REVIEW counts).

In process_batch() final summary:
1. Count invoices by status:
   ```python
   status_counts = {"OK": 0, "PARTIAL": 0, "REVIEW": 0, "FAILED": results["failed"]}
   for invoice_result in invoice_results:
       status = invoice_result["validation_result"].status
       status_counts[status] = status_counts.get(status, 0) + 1
   ```

2. Update summary output:
   ```python
   print(f"Done: {results['processed']} processed. OK={status_counts['OK']}, PARTIAL={status_counts['PARTIAL']}, REVIEW={status_counts['REVIEW']}, failed={status_counts['FAILED']}.")
   ```

3. Include review report info if any created:
   ```python
   review_count = sum(1 for r in invoice_results if r["validation_result"].status == "REVIEW")
   if review_count > 0:
       print(f"Review reports: {review_count} invoice(s) in review/ folder")
   ```

Update status output per invoice (in loop) to show confidence if available:
```python
status_line = f"[{i}/{total}] {pdf_file.name} → {result['status']}"
if result["validation_result"]:
    validation = result["validation_result"]
    if validation.status == "REVIEW":
        status_line += f" (InvoiceNoConfidence={result['invoice_header'].invoice_number_confidence:.2f}, TotalConfidence={result['invoice_header'].total_confidence:.2f})"
    elif validation.status == "PARTIAL":
        status_line += f" (Diff={validation.diff:.2f} SEK)"
status_line += f" ({result['line_count']} rader)"
```

This provides more detail about why status is REVIEW or PARTIAL.
  </action>
  <verify>python -c "from src.cli.main import process_batch; # Verify summary output"</verify>
  <done>Batch summary output updated with validation statistics (OK/PARTIAL/REVIEW counts), per-invoice status shows confidence/diff info</done>
</task>

<task type="auto">
  <name>Task 5: Update unit tests for CLI integration</name>
  <files>tests/test_cli.py</files>
  <action>
Update existing CLI unit tests and add new tests for validation integration.

Tests to add/update:
1. Test process_invoice() returns validation_result:
   - Verify validation_result in return dict
   - Verify status comes from validation_result.status (not hardcoded)

2. Test process_batch() creates review reports:
   - Verify review reports created for REVIEW status invoices
   - Verify review reports NOT created for OK/PARTIAL status invoices
   - Verify review folder structure correct

3. Test Excel export receives validation data:
   - Verify Excel file includes control columns
   - Verify control column values match validation data
   - Verify validation data correctly grouped per invoice (not mixed)

4. Test batch summary statistics:
   - Verify summary shows OK/PARTIAL/REVIEW counts
   - Verify review report count shown if any created

5. Test per-invoice status output:
   - Verify status line shows confidence for REVIEW
   - Verify status line shows diff for PARTIAL

Use pytest fixtures and mocks for InvoiceHeader, ValidationResult, InvoiceLine.
Use tempfile for output directories.

Ensure tests run with `pytest tests/test_cli.py -v`.
  </action>
  <verify>pytest tests/test_cli.py -v</verify>
  <done>CLI unit tests updated, validation integration tested, review report creation tested, Excel export with validation data tested</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_cli.py -v passes
- [ ] Validation step integrated into process_invoice()
- [ ] Status comes from ValidationResult (not hardcoded)
- [ ] Review reports created for REVIEW status invoices only
- [ ] Excel export receives validation data via invoice_metadata
- [ ] Validation data correctly grouped per invoice (not mixed in batch)
- [ ] Batch summary shows validation statistics (OK/PARTIAL/REVIEW counts)
- [ ] Per-invoice status output shows confidence/diff info
</verification>

<success_criteria>

- All tasks completed
- Validation step integrated into CLI pipeline
- Status assignment uses ValidationResult
- Review reports created for REVIEW status invoices
- Excel export receives validation data and includes control columns
- Validation data correctly grouped per invoice in batch processing
- Batch summary includes validation statistics
- Unit tests pass with >80% coverage
- No type errors or linting issues

</success_criteria>

<output>
After completion, create `.planning/phases/03-validation/03-04-SUMMARY.md`
</output>
