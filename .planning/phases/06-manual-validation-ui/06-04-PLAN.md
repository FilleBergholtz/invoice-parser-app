---
phase: 06-manual-validation-ui
plan: 04
type: execute
wave: 1
gap_closure: true
depends_on: ["06-01", "06-02", "06-03"]
files_modified: [src/ui/views/pdf_viewer.py, src/ui/views/main_window.py, src/ui/views/candidate_selector.py]
autonomous: true
source: 06-UAT.md
gaps:
  - "PDF viewer supports zoom for better visibility"
  - "User can select candidate with arrow keys and Enter in validation UI"
  - "Candidate list shows amounts (SEK) and confidence; one click = select"
---

<objective>
Close Phase 6 UAT gaps: PDF zoom, keyboard selection in validation UI, and candidate list populated from processing result.

Purpose: Address 06-UAT failures (zoom, keyboard, empty candidate list). No new features—fix gaps only.

Output: Zoom in PDF viewer; keyboard selection works; candidates loaded and displayed when available.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-manual-validation-ui/06-UAT.md
@.planning/phases/06-manual-validation-ui/06-CONTEXT.md
@src/ui/views/pdf_viewer.py
@src/ui/views/candidate_selector.py
@src/ui/views/main_window.py
@src/ui/services/engine_runner.py
</context>

<gaps_from_uat>

1. **PDF zoom**  
   - truth: "PDF viewer supports zoom for better visibility"  
   - reason: User reported "svårt att se, hade varit bra om man kunde zooma"  
   - severity: major  

2. **Keyboard selection**  
   - truth: "User can select candidate with arrow keys and Enter in validation UI"  
   - reason: User reported "kan inte välja med piltangenterna eller nåt annat"  
   - severity: major  

3. **Candidate list**  
   - truth: "Candidate list shows amounts (SEK) and confidence; one click = select"  
   - reason: User reported "nej"; list empty because _load_candidates_from_result returns []  
   - severity: major  

</gaps_from_uat>

<tasks>

<task type="auto">
  <name>Task 1: Add zoom to PDF viewer</name>
  <files>src/ui/views/pdf_viewer.py</files>
  <action>
Add user-controlled zoom to PDFViewer.

**Options (pick one):**
- **A)** `wheelEvent`: Ctrl+scroll zooms in/out; optional step (e.g. 1.1x per step). Use `QGraphicsView.scale()` and store zoom factor. Clamp zoom (e.g. 0.5x–4x) to avoid extreme scales.
- **B)** Toolbar buttons: "+" / "-" next to viewer that call `scale(factor)` or adjust view transform. Simpler but requires UI changes in main_window.

Prefer **A** (Ctrl+scroll) if no extra widgets desired. Ensure zoom preserves aspect ratio and does not break click-to-PDF coordinate mapping (scale_factor used in mousePressEvent must account for view transform).

**Acceptance:**
- User can zoom in/out in PDF viewer (e.g. Ctrl+scroll or +/-).
- Zoom is clamped; no crash on excessive zoom.
</action>
</task>

<task type="auto">
  <name>Task 2: Fix keyboard selection in validation UI</name>
  <files>src/ui/views/main_window.py, src/ui/views/candidate_selector.py, src/ui/views/pdf_viewer.py</files>
  <action>
Ensure arrow keys and Enter work for candidate selection when validation UI is visible.

**Current:** CandidateSelector has `keyPressEvent` for Up/Down/Enter/Escape. When there are **no** candidates, it returns early and keys do nothing. When there **are** candidates, focus may move to PDF viewer on click, so keys go to viewer instead of selector.

**Changes:**
1. **Focus:** When showing validation UI, call `candidate_selector.setFocus()` (already done). Ensure PDF viewer does **not** take focus on click when we want keyboard in selector. Option: make PDF viewer `setFocusPolicy(Qt.NoFocus)` during validation, or explicitly refocus selector after PDF click (currently `_on_pdf_candidate_clicked` already calls `select_candidate`; consider calling `candidate_selector.setFocus()` there too).
2. **Empty list:** Keyboard gap is partly that user "can't select" when list is empty (Task 3 fixes that). Once candidates exist, verify focus remains on selector so keys work. Add explicit `setFocus()` on selector after any PDF click that updates selection.
3. **Optional:** If focus still misbehaves, add a `QShortcut` or key-event filter at main_window level for Up/Down/Enter when validation visible, and forward to selector. Prefer fixing focus first.

**Acceptance:**
- When validation UI is visible and candidates exist, Up/Down/Enter work in selector (user can select without mouse).
- Focus stays on selector after PDF click when selecting a candidate.
</action>
</task>

<task type="auto">
  <name>Task 3: Load candidates from processing result</name>
  <files>src/ui/views/main_window.py, src/ui/services/engine_runner.py</files>
  <action>
Implement _load_candidates_from_result so the candidate list is populated from processing output.

**Current:** `_load_candidates_from_result()` always returns `[]`. GUI receives `run_summary.json` (RunSummary) via `result_ready`; stored in `processing_result`. RunSummary has `quality_scores` (per-invoice), but we need `total_candidates` and optionally traceability for the **first** REVIEW invoice (or the one corresponding to `input_path`).

**Options:**
- **A)** **Extend run_summary / engine output:** When CLI processes a single PDF (or first REVIEW invoice), include in run_summary a `validation` (or similar) blob: `{ "candidates": [...], "traceability": {...} }` for that invoice. Format `candidates` as list of `{ "amount", "score", "row_index", "keyword_type" }`. Engine runner already emits run_summary; main_window reads it. Implement `_load_candidates_from_result` to use `processing_result.get("validation", {}).get("candidates", [])` and set `current_invoice_header` from that context.
- **B)** **Per-invoice artifact:** Engine writes `output_dir/artifacts/<run_id>/<virtual_invoice_id>_validation.json` with `total_candidates` and traceability. GUI loads `run_summary.artifacts_dir`, finds latest run, matches `input_path` to virtual_invoice_id (or first REVIEW), and reads that JSON. More flexible but requires engine changes and path resolution.

Prefer **A** if we can add a small `validation` payload to run_summary for single-PDF GUI runs without big CLI refactors. **B** if run_summary must stay minimal.

**Engine side:** run_engine uses CLI. CLI populates RunSummary and saves run_summary.json. For **single-file** GUI runs, we could add a hook: when `process_batch` runs with one input file and we have at least one REVIEW result, set `summary.validation = { "candidates": [...], "traceability": ... }` from the first REVIEW virtual_result (invoice_header.total_candidates, total_traceability). Serialize traceability carefully (e.g. evidence dict only).

**GUI side:** In `_load_candidates_from_result`, read `self.processing_result`. If `validation.candidates` exists, return it and store traceability for PDF viewer. Else return `[]`. Populate `current_invoice_header` from validation or minimal mock so correction saving still works.

**Acceptance:**
- For a single-PDF run with REVIEW and total_candidates present, validation UI shows non-empty candidate list (amounts, confidence), one click = select.
- Bekräfta val / corrections remain functional when candidates loaded.
</action>
</task>

</tasks>

<verification>

- Re-run 06-UAT tests 2, 4, 6, 7 (zoom, candidate list, keyboard, corrections) after implementing.
- Confirm gaps "PDF viewer supports zoom", "User can select with arrow keys and Enter", "Candidate list shows amounts and confidence" are closed.

</verification>
