---
phase: 09-ai-data-analysis
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified: [src/analysis/query_processor.py]
autonomous: true

must_haves:
  truths:
    - "System can parse natural language queries about invoice data"
    - "System extracts query intent, filters, and aggregations from natural language"
  artifacts:
    - path: "src/analysis/query_processor.py"
      provides: "Natural language query processing"
      exports: ["parse_query", "QueryIntent"]
  key_links:
    - from: "src/analysis/query_processor.py"
      to: "src/ai/providers.py"
      via: "Uses AI to parse natural language queries"
      pattern: "AIProvider|extract"
    - from: "src/analysis/query_processor.py"
      to: "src/analysis/data_loader.py"
      via: "Uses InvoiceDataStore for data retrieval"
      pattern: "InvoiceDataStore"
---

<objective>
Create natural language query processor that uses AI to parse queries and extract intent, filters, and aggregations.

Purpose: Build query processor that takes natural language questions, uses AI to parse them into structured queries, and extracts filters/aggregations for data retrieval.

Output: QueryIntent model and parse_query function.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-data-analysis/09-CONTEXT.md
@src/ai/providers.py
@src/analysis/data_loader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query processor with AI</name>
  <files>src/analysis/query_processor.py</files>
  <action>
Create natural language query processor module `src/analysis/query_processor.py`.

**Dependencies:**
- AI providers from Phase 8
- Pydantic for structured outputs

**Classes/Models to implement:**

1. `QueryIntent` (Pydantic model):
   - Fields:
     - query_type: str ("filter", "aggregate", "summarize", "compare")
     - filters: Dict[str, Any] (supplier, date_range, amount_range, status, etc.)
     - aggregations: List[str] (sum, count, average, etc.)
     - group_by: Optional[str] (supplier, date, etc.)
     - sort_by: Optional[str] (date, amount, supplier, etc.)
     - limit: Optional[int] (max results)

2. `parse_query(query: str, provider: Optional[AIProvider] = None) -> QueryIntent`:
   - Use AI to parse natural language query
   - Extract query intent, filters, aggregations
   - Return QueryIntent object

**AI Prompt Template:**
- Parse Swedish/English natural language query about invoices
- Extract:
  - Query type (filter/aggregate/summarize/compare)
  - Filters (supplier name, date range, amount range, status)
  - Aggregations (sum, count, average)
  - Group by (supplier, month, etc.)
  - Sort order
  - Limit

**Example Queries:**
- "Visa alla fakturor från Acme Corp i januari" → filter: supplier="Acme Corp", date_range=(2026-01-01, 2026-01-31)
- "Vad är totalsumman för alla fakturor från leverantör X?" → aggregate: sum, filter: supplier="X"
- "Sammanfattning av fakturor i januari" → summarize, date_range=(2026-01-01, 2026-01-31)
- "Jämför fakturor från leverantör A och B" → compare, filters: [supplier="A", supplier="B"]

**Error Handling:**
- Handle AI parsing errors
- Handle invalid query format
- Return default QueryIntent if parsing fails

Add type hints and docstrings.
  </action>
  <verify>python -c "from src.analysis.query_processor import parse_query, QueryIntent; print('Query processor imported successfully')"</verify>
  <done>Query processor created with AI-based natural language parsing</done>
</task>

</tasks>
