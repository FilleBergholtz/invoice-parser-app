---
wave: 1
depends_on:
  - "Phase 21"
files_modified:
  - "src/pipeline/invoice_line_parser.py"
  - "src/pipeline/validation.py"
  - "src/pipeline/column_detection.py"
  - "src/config.py"
  - "src/debug/artifact_manifest.py"
  - "tests/test_validation.py"
  - "tests/test_invoice_line_parser.py"
  - "tests/test_column_detection.py"
  - "tests/test_debug_artifacts.py"
autonomous: true
---

# Plan 22-01 — Valideringsdriven om-extraktion (mode B)

## Mål
Validering styr om-extraktion och sparar debug-artefakter vid mismatch. Implementera table-parser mode B (position/kolumn-baserad) som fallback när text-baserad parsing misslyckas.

## Must-haves
- VAL-01: `sum(line_items.netto)` matchar "Nettobelopp exkl. moms" inom ±0,50 SEK.
- VAL-02: `netto + moms` matchar "Att betala" inom ±0,50 SEK.
- VAL-03: Om VAL-01 fallerar körs **table-parser mode B** (position/kolumn-baserad andra pass).
- VAL-04: Om mismatch kvarstår → status REVIEW och **debug-artefakter** sparas (tabellblockets råtext + tolkade rader).
- VAL-05: `table_parser_mode` är konfigurerbart: `auto|text|pos` (auto kör A och fallback till B).

## Omfattning
- Utöka `validation.py` med specifik validering för nettosumma och "Att betala".
- Skapa `column_detection.py` med gap-based column detection algoritm.
- Implementera table-parser mode B (position/kolumn-baserad parsing) i `invoice_line_parser.py`.
- Lägg till `table_parser_mode` konfiguration i `config.py`.
- Integrera validering i extraction pipeline (validera → om-extraktion vid mismatch).
- Implementera debug-artefakt sparning (tabellblock råtext + tolkade rader).
- Lägg till comprehensive tester för validering, column detection, mode B parsing, och debug artifacts.
- Performance: Mode B ska vara <50ms per invoice (enligt research).

## Utanför scope
- Multipla momssatser (12%, 6%) — kan addresseras i framtida iteration.
- AI-baserad om-extraktion — deterministiska regler först.
- Automatisk korrigering utan REVIEW — osäkra fall går alltid till REVIEW.
- Column span detection — multi-column descriptions behandlas som single column (kan förbättras senare).
- Multi-page column consistency — kolumner detekteras per-page, inte per-document (hanterar layout-variationer).

## Known Considerations

### Column Detection Limitations
- **Gap-based detection** fungerar bra för de flesta fakturor men kan misslyckas på:
  - Fakturor med mycket tight spacing (gaps <20pt)
  - Fakturor med varierande kolumn-spacing (adaptiv threshold kan behövas)
  - Fakturor utan tydliga kolumn-gränser (fallback till mode A)

### Mode B Performance
- Mode B är långsammare än mode A (column detection + token assignment overhead)
- Bara körs när nödvändigt (valideringsfel eller explicit "pos" mode)
- Performance måste mätas i production - optimera om >50ms per invoice

### Hybrid Approach Complexity
- Hybrid position+content är mer komplex än pure position eller pure content
- Men nödvändig för robusthet - pure position misslyckas när kolumner överlappar
- Content patterns (VAT%, unit keywords) används för validering och korrektion

### Debug Artifacts Size
- Debug artifacts kan bli stora för fakturor med många rader
- Överväg komprimering eller size limits om artifacts blir för stora
- Token-level data (table_block_tokens.json) är optional för att minska size

## Tasks (XML)
<tasks>
  <task id="22-01-1" title="Validering för nettosumma och Att betala">
    <details>
      Implementera funktioner i `validation.py`:
      
      1. `validate_netto_sum(line_items: List[InvoiceLine], netto_total: Decimal, tolerance: Decimal = Decimal("0.50")) -> Tuple[bool, Decimal]`
         - Beräknar `sum(line.netto for line in line_items)` (använd line.netto, inte total_amount)
         - Jämför mot `netto_total` (från "Nettobelopp exkl. moms" extraherat från footer)
         - Returnerar (validation_passed, diff) där diff = netto_total - netto_sum
         - Validation passes om abs(diff) <= tolerance
      
      2. `validate_total_with_vat(netto_sum: Decimal, vat_amount: Decimal, total_with_vat: Decimal, tolerance: Decimal = Decimal("0.50")) -> Tuple[bool, Decimal]`
         - Beräknar `netto_sum + vat_amount` (vat_amount = netto_sum × 0.25 för 25% moms)
         - Jämför mot `total_with_vat` (från "Att betala" extraherat från footer)
         - Returnerar (validation_passed, diff) där diff = total_with_vat - (netto_sum + vat_amount)
         - Validation passes om abs(diff) <= tolerance
      
      Integration:
      - Använd `footer_extractor.py` för att extrahera "Nettobelopp exkl. moms" och "Att betala"
      - Använd befintlig `validate_total_against_line_items()` som referens men
        specifikt för nettosumma och VAT-validering
      - Hantera edge case: line_items kan sakna netto field (använd total_amount som fallback)
      
      Requirements: VAL-01, VAL-02
    </details>
    <requirements>VAL-01, VAL-02</requirements>
  </task>
  <task id="22-01-2a" title="Column detection modul">
    <details>
      Skapa `src/pipeline/column_detection.py` med gap-based column detection:
      
      Funktioner:
      1. `detect_columns_gap_based(rows: List[Row], min_gap: float = 20.0) -> List[float]`
         - Samlar alla token X-positions (centers: token.x + width/2)
         - Sorterar X-positions
         - Hittar gaps > min_gap (kolumn-gränser)
         - Beräknar kolumn-centra (midpoints mellan boundaries)
         - Returnerar lista av kolumn-center X-positions (sorterade vänster till höger)
      
      2. `map_columns_from_header(header_row: Row, column_centers: List[float]) -> Dict[str, int]`
         - Mappar kolumner till fält via header row keywords
         - Field keywords: description, quantity, unit, unit_price, vat_percent, netto
         - Returnerar dict: {'description': 1, 'quantity': 2, ...}
         - Fallback: None om header saknas eller inte matchar
      
      3. `assign_tokens_to_columns(row: Row, column_centers: List[float]) -> Dict[int, List[Token]]`
         - Assignerar tokens till närmaste kolumn (nearest-neighbor)
         - Använder token center (inte left edge) för bättre precision
         - Returnerar dict: {column_idx: [tokens]}
      
      Edge cases:
      - Inga gaps hittade → single column (returnera median X-position)
      - För många gaps → använd adaptiv threshold (median gap × 1.5)
      - Header row saknas → returnera None från map_columns_from_header
      
      Research ref: Pattern 1 (Gap-Based Column Detection), Pattern 2 (Header Row Column Mapping), Pattern 3 (Token-to-Column Assignment)
      Pitfalls att undvika: Over-clustering, Under-clustering, Column overlap
      
      Requirements: VAL-03
    </details>
    <requirements>VAL-03</requirements>
  </task>
  <task id="22-01-2b" title="Mode B field extraction">
    <details>
      Implementera position-based field extraction i `invoice_line_parser.py`:
      
      Funktion: `extract_invoice_lines_mode_b(segment: Segment, table_rows: List[Row]) -> List[InvoiceLine]`
      
      Algorithm:
      1. Detektera kolumner via `detect_columns_gap_based()` (från column_detection.py)
      2. Om kolumn-detektion misslyckas → fallback till mode A
      3. Mappa kolumner till fält via `map_columns_from_header()` (om header finns)
      4. För varje row:
         a. Assignera tokens till kolumner via `assign_tokens_to_columns()`
         b. Extrahera fält med hybrid approach (position + content):
            - Description: Från mapped column eller första kolumner
            - Quantity: Från mapped column eller via unit keyword (left of unit)
            - Unit: Från mapped column eller via unit keywords search
            - Unit_price: Från mapped column eller via spatial relationship
            - VAT%: Från mapped column eller via pattern search (25.00/25,00)
            - Netto: Från mapped column ELLER rightmost amount efter VAT% (VAT%-anchored)
         c. Skapa InvoiceLine objekt (samma struktur som mode A)
      5. Använd samma wrap detection som mode A (för multi-line items)
      
      Hybrid approach (research Pattern 4):
      - Position: Använd kolumn-mappning om tillgänglig
      - Content: Använd VAT% patterns, unit keywords för validering/korrektion
      - Fallback: Om position misslyckas, använd content-based (samma som mode A)
      
      Performance target: <50ms per invoice (enligt research)
      - Cache column detection result (kolumner ändras inte inom table)
      - Optimera token assignment (sorted column centers för binary search)
      
      Research ref: Pattern 4 (Hybrid Position+Content Field Extraction), Pattern 5 (Column Width Normalization)
      Pitfalls att undvika: Variable column widths, Merged cells, Ragged columns
      
      Requirements: VAL-03
    </details>
    <requirements>VAL-03</requirements>
  </task>
  <task id="22-01-3" title="table_parser_mode konfiguration">
    <details>
      Lägg till konfiguration i `config.py`:
      
      1. `get_table_parser_mode() -> str` - Returnerar "auto" | "text" | "pos"
      2. `set_table_parser_mode(mode: str)` - Sätter mode
      3. Default: "auto" (kör mode A, fallback till mode B vid valideringsfel)
      
      Lägg till i supplier profile YAML:
      ```yaml
      table_parser_mode: auto  # auto | text | pos
      ```
      
      Integration:
      - `invoice_line_parser.py` läser mode från config
      - "auto": Kör mode A, vid valideringsfel → mode B
      - "text": Alltid mode A (text-based)
      - "pos": Alltid mode B (position-based)
      
      Requirements: VAL-05
    </details>
    <requirements>VAL-05</requirements>
  </task>
  <task id="22-01-4" title="Valideringsdriven om-extraktion pipeline">
    <details>
      Integrera validering och om-extraktion i extraction pipeline:
      
      Flöde:
      1. Extrahera line items med mode A (text-based, befintlig kod)
      2. Extrahera "Nettobelopp exkl. moms" från footer (redan implementerat i footer_extractor.py)
      3. Validera nettosumma mot "Nettobelopp exkl. moms" (VAL-01) via `validate_netto_sum()`
      4. Om VAL-01 fail OCH `table_parser_mode == "auto"` → kör mode B (position-based)
      5. Om mode är "pos" → kör mode B direkt (hoppa över mode A)
      6. Om mode är "text" → kör endast mode A (ingen fallback)
      7. Validera nettosumma igen (mode B resultat om mode B användes)
      8. Om fortfarande fail → extrahera "Att betala" från footer och validera (VAL-02)
      9. Om mismatch kvarstår → status REVIEW + spara debug artifacts (VAL-04)
      
      Performance considerations:
      - Validering overhead: <5ms per invoice
      - Mode B bara körs när nödvändigt (valideringsfel eller explicit "pos" mode)
      - Cache column detection result om möjligt (kolumner ändras inte inom table)
      
      Integration points:
      - `invoice_line_parser.py`: `extract_invoice_lines()` uppdateras för att:
        - Läsa `table_parser_mode` från config
        - Köra validering efter mode A extraction
        - Köra mode B om validering failar (och mode är "auto")
        - Returnera mode B resultat om mode B användes
      
      - `validation.py`: Anropa från extraction pipeline
      
      Requirements: VAL-01, VAL-02, VAL-03
    </details>
    <requirements>VAL-01, VAL-02, VAL-03</requirements>
  </task>
  <task id="22-01-5" title="Debug-artefakter sparning">
    <details>
      Implementera debug-artefakt sparning vid valideringsmismatch:
      
      Funktion: `save_table_debug_artifacts(artifacts_dir: Path, invoice_id: str, table_rows: List[Row], line_items: List[InvoiceLine], validation_result: ValidationResult)`
      
      Sparar:
      1. `table_block_raw_text.txt` - Tabellblockets råtext (alla rows.text, newline-separated)
      2. `parsed_lines.json` - Tolkade line items (JSON format med alla InvoiceLine fields)
      3. `validation_result.json` - Validation result med:
         - netto_sum (beräknad från line items)
         - netto_total (från footer)
         - diff (netto_total - netto_sum)
         - validation_passed (bool)
         - mode_used ("A" eller "B")
         - errors/warnings (lista)
      4. `table_block_tokens.json` - Token-level data för debugging (optional, för advanced debugging)
         - Innehåller: token text, x, y, width, height per row
      
      Format:
      - JSON files använder indent=2 för läsbarhet
      - Text files använder UTF-8 encoding
      - Alla filer inkluderar timestamp i metadata
      
      Integration:
      - Anropas från extraction pipeline när mismatch kvarstår efter mode B
      - Sparas i `artifacts_dir/invoices/{invoice_id}/table_debug/`
      - Läggs till i `ArtifactManifest` för traceability
      
      Requirements: VAL-04
    </details>
    <requirements>VAL-04</requirements>
  </task>
  <task id="22-01-6" title="Tester för validering och mode B">
    <details>
      Skapa/utöka tester:
      
      **test_validation.py:**
      - `test_validate_netto_sum`: VAL-01 validering (pass/fail scenarios)
        - Pass: diff = 0.30 SEK (within tolerance)
        - Fail: diff = 0.60 SEK (outside tolerance)
        - Edge case: diff = 0.50 SEK (exactly at tolerance boundary)
        - Edge case: line_items saknar netto field (använd total_amount)
      - `test_validate_total_with_vat`: VAL-02 validering (pass/fail scenarios)
        - Pass: netto_sum + vat (25%) matches "Att betala" within tolerance
        - Fail: mismatch > 0.50 SEK
        - Edge case: vat_amount calculation (netto_sum × 0.25)
      - `test_validation_tolerance`: ±0,50 SEK tolerance edge cases
        - ±0.49 SEK (pass)
        - ±0.50 SEK (pass, boundary)
        - ±0.51 SEK (fail)
      - `test_validation_with_mixed_vat`: Framtida: multipla momssatser (out of scope)
      
      **test_column_detection.py (ny fil):**
      - `test_gap_based_column_detection`: Gap-based algoritm (normal case)
      - `test_column_detection_single_column`: Edge case: inga gaps
      - `test_column_detection_over_clustering`: Pitfall: för många kolumner
      - `test_column_detection_under_clustering`: Pitfall: för få kolumner
      - `test_header_row_column_mapping`: Header-based field mapping
      - `test_token_to_column_assignment`: Token assignment (nearest-neighbor)
      - `test_column_detection_variable_widths`: Variable column widths
      
      **test_invoice_line_parser.py:**
      - `test_mode_b_position_based_parsing`: Mode B extraction (full pipeline)
      - `test_mode_b_hybrid_field_extraction`: Hybrid position+content approach
      - `test_mode_b_fallback_to_mode_a`: Fallback när column detection misslyckas
      - `test_auto_mode_fallback`: Auto mode → mode B vid valideringsfel
      - `test_text_mode_always_a`: Text mode använder alltid mode A
      - `test_pos_mode_always_b`: Pos mode använder alltid mode B
      - `test_mode_b_performance`: Performance <50ms per invoice
      
      **test_debug_artifacts.py (ny fil):**
      - `test_save_table_debug_artifacts`: Debug artifact sparning
      - `test_debug_artifacts_on_mismatch`: Artifacts sparas vid mismatch
      - `test_debug_artifacts_format`: JSON format validation
      
      Requirements: VAL-01, VAL-02, VAL-03, VAL-04, VAL-05
    </details>
    <requirements>VAL-01, VAL-02, VAL-03, VAL-04, VAL-05</requirements>
  </task>
  <task id="22-01-7" title="Integration och regression tests">
    <details>
      Lägg till integration tests:
      
      - `test_validation_driven_re_extraction`: Full pipeline test
        - Mode A extraction → validering fail → mode B → success
      - `test_review_status_on_mismatch`: Status REVIEW när mismatch kvarstår
      - `test_debug_artifacts_integration`: Debug artifacts sparas korrekt
      - `test_config_table_parser_mode`: Konfiguration fungerar
      
      Regression tests:
      - Phase 20-21 tests fortfarande passerar (table blocks, wrap detection, VAT% extraction)
      - Befintlig validation kod fungerar som förut (ingen breaking change)
      - Backward compatibility med mode A (default behavior, "auto" mode)
      - Performance: Mode A overhead <1ms (validering), Mode B <50ms (enligt research)
      
      Requirements: All VAL-*
    </details>
    <requirements>VAL-01, VAL-02, VAL-03, VAL-04, VAL-05</requirements>
  </task>
</tasks>

## Verifiering
- VAL-01: Nettosumma valideras mot "Nettobelopp exkl. moms" inom ±0,50 SEK.
- VAL-02: Netto + moms valideras mot "Att betala" inom ±0,50 SEK.
- VAL-03: Mode B körs automatiskt när VAL-01 fallerar (auto mode).
- VAL-04: Debug-artefakter sparas vid kvarstående mismatch (REVIEW status).
- VAL-05: `table_parser_mode` är konfigurerbart och fungerar (auto/text/pos).
- Column detection fungerar korrekt (gap-based, hanterar edge cases).
- Mode B parsing använder hybrid position+content approach.
- Performance: Mode B <50ms per invoice (research target).
- Alla edge case tests passerar (tolerance boundaries, mode switching, column detection pitfalls).
- Phase 20-21 regression tests passerar (backward compatibility).

## Leverabler
- Uppdaterad `validation.py` med nettosumma och VAT-validering (VAL-01, VAL-02).
- Ny `column_detection.py` med gap-based column detection algoritm.
- Ny `extract_invoice_lines_mode_b()` i `invoice_line_parser.py` (position-based parsing).
- Konfiguration för `table_parser_mode` i `config.py` (VAL-05).
- Debug-artefakt sparning i `debug/artifact_manifest.py` (VAL-04).
- Comprehensive test suite:
  - `test_validation.py` - Nettosumma och VAT-validering
  - `test_column_detection.py` - Column detection algoritmer
  - `test_invoice_line_parser.py` - Mode B parsing och mode switching
  - `test_debug_artifacts.py` - Debug artifact sparning

## Research References
- **22-RESEARCH.md** - Position-based parsing patterns, column detection algorithms, hybrid approaches
  - Pattern 1: Gap-Based Column Detection (rekommenderat, enklare än k-means)
  - Pattern 2: Header Row Column Mapping (förbättrar accuracy)
  - Pattern 3: Token-to-Column Assignment (nearest-neighbor)
  - Pattern 4: Hybrid Position+Content Field Extraction (nödvändig för robusthet)
  - Pattern 5: Column Width Normalization (för varierande page sizes)
  - 8 Common Pitfalls med lösningar (over-clustering, under-clustering, column overlap, etc.)
- Phase 20: VAT%-anchored net amount extraction, positional parsing patterns
- Phase 21: Multi-line items, wrap detection, spatial proximity
- Existing validation: `validation.py`, `confidence_scoring.py`
- Debug artifacts: `debug/artifact_manifest.py`, `debug/artifact_index.py`
- Heuristics: `docs/04_heuristics.md` - Column-based parsing heuristics

## Key Implementation Notes

### Column Detection Strategy
- **Gap-based detection** (inte k-means) - Enklare, mer robust, kräver inte kolumnantal
- **Min gap threshold**: 20pt (kan göras adaptiv: median gap × 1.5)
- **Edge cases**: Single column (inga gaps), over-clustering (för många gaps), under-clustering (för få gaps)

### Hybrid Approach (Critical)
- **Position identifies column** - Använd kolumn-mappning om tillgänglig
- **Content validates field** - Använd VAT% patterns, unit keywords för validering
- **Fallback to content-based** - Om position misslyckas, använd content (samma som mode A)

### Performance Targets
- Column detection: <5ms per table
- Token assignment: <2ms per row
- Mode B total overhead: <50ms per invoice
- Validation overhead: <5ms per invoice

### Integration with Phase 20-21
- Mode B använder samma VAT%-anchored extraction som mode A
- Mode B använder samma wrap detection som mode A (multi-line items)
- Mode B använder samma table block boundaries som mode A
- Mode B är fallback, inte replacement - mode A är primary path
