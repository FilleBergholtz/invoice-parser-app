---
wave: 1
depends_on:
  - "Phase 21"
files_modified:
  - "src/pipeline/invoice_line_parser.py"
  - "src/pipeline/validation.py"
  - "src/config.py"
  - "src/debug/artifact_manifest.py"
  - "tests/test_validation.py"
  - "tests/test_invoice_line_parser.py"
autonomous: true
---

# Plan 22-01 — Valideringsdriven om-extraktion (mode B)

## Mål
Validering styr om-extraktion och sparar debug-artefakter vid mismatch. Implementera table-parser mode B (position/kolumn-baserad) som fallback när text-baserad parsing misslyckas.

## Must-haves
- VAL-01: `sum(line_items.netto)` matchar "Nettobelopp exkl. moms" inom ±0,50 SEK.
- VAL-02: `netto + moms` matchar "Att betala" inom ±0,50 SEK.
- VAL-03: Om VAL-01 fallerar körs **table-parser mode B** (position/kolumn-baserad andra pass).
- VAL-04: Om mismatch kvarstår → status REVIEW och **debug-artefakter** sparas (tabellblockets råtext + tolkade rader).
- VAL-05: `table_parser_mode` är konfigurerbart: `auto|text|pos` (auto kör A och fallback till B).

## Omfattning
- Utöka `validation.py` med specifik validering för nettosumma och "Att betala".
- Implementera table-parser mode B (position/kolumn-baserad parsing) i `invoice_line_parser.py`.
- Lägg till `table_parser_mode` konfiguration i `config.py`.
- Integrera validering i extraction pipeline (validera → om-extraktion vid mismatch).
- Implementera debug-artefakt sparning (tabellblock råtext + tolkade rader).
- Lägg till comprehensive tester för validering, mode B parsing, och debug artifacts.

## Utanför scope
- Multipla momssatser (12%, 6%) — kan addresseras i framtida iteration.
- AI-baserad om-extraktion — deterministiska regler först.
- Automatisk korrigering utan REVIEW — osäkra fall går alltid till REVIEW.

## Tasks (XML)
<tasks>
  <task id="22-01-1" title="Validering för nettosumma och Att betala">
    <details>
      Implementera funktioner i `validation.py`:
      
      1. `validate_netto_sum(line_items: List[InvoiceLine], netto_total: Decimal, tolerance: Decimal = Decimal("0.50")) -> Tuple[bool, Decimal]`
         - Beräknar `sum(line.netto for line in line_items)`
         - Jämför mot `netto_total` (från "Nettobelopp exkl. moms")
         - Returnerar (validation_passed, diff)
      
      2. `validate_total_with_vat(netto_sum: Decimal, vat_amount: Decimal, total_with_vat: Decimal, tolerance: Decimal = Decimal("0.50")) -> Tuple[bool, Decimal]`
         - Beräknar `netto_sum + vat_amount`
         - Jämför mot `total_with_vat` (från "Att betala")
         - Returnerar (validation_passed, diff)
      
      Använd befintlig `validate_total_against_line_items()` som referens men
      specifikt för nettosumma och VAT-validering.
      
      Requirements: VAL-01, VAL-02
    </details>
    <requirements>VAL-01, VAL-02</requirements>
  </task>
  <task id="22-01-2" title="Table parser mode B (position-based)">
    <details>
      Implementera position/kolumn-baserad parsing i `invoice_line_parser.py`:
      
      Funktion: `extract_invoice_lines_mode_b(segment: Segment, table_rows: List[Row]) -> List[InvoiceLine]`
      
      Algorithm:
      1. Identifiera kolumner via spatial analysis (X-position clustering)
      2. Gruppera tokens per kolumn baserat på X-position
      3. Mappa kolumner till fält: description, quantity, unit, unit_price, vat%, netto
      4. Extrahera rader rad-för-rad med kolumn-baserad parsing
      5. Använd samma VAT%-anchored net amount extraction som mode A
      
      Skillnader från mode A (text-based):
      - Mode A: Parsar från row.text med regex patterns
      - Mode B: Parsar från kolumn-positioner (mer robust för varierande layouts)
      
      Kolumn-identifiering:
      - Clustera tokens per X-position (k-means eller rule-based)
      - Identifiera kolumner via header row (om tillgänglig)
      - Fallback: Använd spatial gaps för att detektera kolumner
      
      Requirements: VAL-03
    </details>
    <requirements>VAL-03</requirements>
  </task>
  <task id="22-01-3" title="table_parser_mode konfiguration">
    <details>
      Lägg till konfiguration i `config.py`:
      
      1. `get_table_parser_mode() -> str` - Returnerar "auto" | "text" | "pos"
      2. `set_table_parser_mode(mode: str)` - Sätter mode
      3. Default: "auto" (kör mode A, fallback till mode B vid valideringsfel)
      
      Lägg till i supplier profile YAML:
      ```yaml
      table_parser_mode: auto  # auto | text | pos
      ```
      
      Integration:
      - `invoice_line_parser.py` läser mode från config
      - "auto": Kör mode A, vid valideringsfel → mode B
      - "text": Alltid mode A (text-based)
      - "pos": Alltid mode B (position-based)
      
      Requirements: VAL-05
    </details>
    <requirements>VAL-05</requirements>
  </task>
  <task id="22-01-4" title="Valideringsdriven om-extraktion pipeline">
    <details>
      Integrera validering och om-extraktion i extraction pipeline:
      
      Flöde:
      1. Extrahera line items med mode A (text-based, befintlig kod)
      2. Validera nettosumma mot "Nettobelopp exkl. moms" (VAL-01)
      3. Om VAL-01 fail → kör mode B (position-based)
      4. Validera nettosumma igen (mode B resultat)
      5. Om fortfarande fail → validera "Att betala" (VAL-02)
      6. Om mismatch kvarstår → status REVIEW + spara debug artifacts
      
      Integration points:
      - `invoice_line_parser.py`: `extract_invoice_lines()` uppdateras för att:
        - Läsa `table_parser_mode` från config
        - Köra validering efter mode A extraction
        - Köra mode B om validering failar (och mode är "auto")
        - Returnera mode B resultat om mode B användes
      
      - `validation.py`: Anropa från extraction pipeline
      
      Requirements: VAL-01, VAL-02, VAL-03
    </details>
    <requirements>VAL-01, VAL-02, VAL-03</requirements>
  </task>
  <task id="22-01-5" title="Debug-artefakter sparning">
    <details>
      Implementera debug-artefakt sparning vid valideringsmismatch:
      
      Funktion: `save_table_debug_artifacts(artifacts_dir: Path, invoice_id: str, table_rows: List[Row], line_items: List[InvoiceLine], validation_result: ValidationResult)`
      
      Sparar:
      1. `table_block_raw_text.txt` - Tabellblockets råtext (alla rows.text)
      2. `parsed_lines.json` - Tolkade line items (JSON format)
      3. `validation_result.json` - Validation result med diff, status, errors
      4. `table_block_tokens.json` - Token-level data för debugging (optional)
      
      Integration:
      - Anropas från extraction pipeline när mismatch kvarstår efter mode B
      - Sparas i `artifacts_dir/invoices/{invoice_id}/table_debug/`
      - Läggs till i `ArtifactManifest` för traceability
      
      Requirements: VAL-04
    </details>
    <requirements>VAL-04</requirements>
  </task>
  <task id="22-01-6" title="Tester för validering och mode B">
    <details>
      Skapa/utöka tester:
      
      **test_validation.py:**
      - `test_validate_netto_sum`: VAL-01 validering (pass/fail scenarios)
      - `test_validate_total_with_vat`: VAL-02 validering (pass/fail scenarios)
      - `test_validation_tolerance`: ±0,50 SEK tolerance edge cases
      - `test_validation_with_mixed_vat`: Framtida: multipla momssatser
      
      **test_invoice_line_parser.py:**
      - `test_mode_b_position_based_parsing`: Mode B extraction
      - `test_mode_b_column_detection`: Kolumn-identifiering
      - `test_auto_mode_fallback`: Auto mode → mode B vid valideringsfel
      - `test_text_mode_always_a`: Text mode använder alltid mode A
      - `test_pos_mode_always_b`: Pos mode använder alltid mode B
      
      **test_debug_artifacts.py (ny fil):**
      - `test_save_table_debug_artifacts`: Debug artifact sparning
      - `test_debug_artifacts_on_mismatch`: Artifacts sparas vid mismatch
      - `test_debug_artifacts_format`: JSON format validation
      
      Requirements: VAL-01, VAL-02, VAL-03, VAL-04, VAL-05
    </details>
    <requirements>VAL-01, VAL-02, VAL-03, VAL-04, VAL-05</requirements>
  </task>
  <task id="22-01-7" title="Integration och regression tests">
    <details>
      Lägg till integration tests:
      
      - `test_validation_driven_re_extraction`: Full pipeline test
        - Mode A extraction → validering fail → mode B → success
      - `test_review_status_on_mismatch`: Status REVIEW när mismatch kvarstår
      - `test_debug_artifacts_integration`: Debug artifacts sparas korrekt
      - `test_config_table_parser_mode`: Konfiguration fungerar
      
      Regression tests:
      - Phase 20-21 tests fortfarande passerar
      - Befintlig validation kod fungerar som förut
      - Backward compatibility med mode A (default behavior)
      
      Requirements: All VAL-*
    </details>
    <requirements>VAL-01, VAL-02, VAL-03, VAL-04, VAL-05</requirements>
  </task>
</tasks>

## Verifiering
- VAL-01: Nettosumma valideras mot "Nettobelopp exkl. moms" inom ±0,50 SEK.
- VAL-02: Netto + moms valideras mot "Att betala" inom ±0,50 SEK.
- VAL-03: Mode B körs automatiskt när VAL-01 fallerar (auto mode).
- VAL-04: Debug-artefakter sparas vid kvarstående mismatch (REVIEW status).
- VAL-05: `table_parser_mode` är konfigurerbart och fungerar (auto/text/pos).
- Alla edge case tests passerar (tolerance boundaries, mode switching).
- Phase 20-21 regression tests passerar (backward compatibility).

## Leverabler
- Uppdaterad `validation.py` med nettosumma och VAT-validering.
- Ny `extract_invoice_lines_mode_b()` i `invoice_line_parser.py`.
- Konfiguration för `table_parser_mode` i `config.py`.
- Debug-artefakt sparning i `debug/artifact_manifest.py`.
- Comprehensive test suite för validering, mode B, och debug artifacts.

## Research References
- Phase 20: VAT%-anchored net amount extraction
- Phase 21: Multi-line items, wrap detection
- Existing validation: `validation.py`, `confidence_scoring.py`
- Debug artifacts: `debug/artifact_manifest.py`, `debug/artifact_index.py`
